name: Approve Tool Submission

on:
  issues:
    types: [labeled]

jobs:
  add-tool:
    if: github.event.label.name == 'approved'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
    steps:
      - uses: actions/checkout@v4

      - name: Parse issue and create tool file
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';

            // Parse form fields from GitHub Issue form
            const getField = (label) => {
              const regex = new RegExp(`### ${label}\\s*\\n\\s*([\\s\\S]*?)(?=\\n###|\\n\\n###|$)`);
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };

            const name = getField('Tool Name');
            const tagline = getField('One-line description');
            const description = getField('Tell us about your tool');
            const github_url = getField('GitHub Repository URL');
            const website_url = getField('Website or Demo URL \\(optional\\)');
            const author = getField('Your Name');
            const author_github = getField('Your GitHub Username');
            const tagsRaw = getField('Tags \\(comma-separated\\)');
            const language = getField('Primary Programming Language');
            const license = getField('License');

            // Validate required fields
            if (!name || !tagline || !github_url || !author || !author_github) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '‚ö†Ô∏è Missing required fields. Please ensure Tool Name, Tagline, GitHub URL, Author, and GitHub Username are filled in.'
              });
              return;
            }

            // Validate GitHub URL format
            if (!/^https:\/\/github\.com\/[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+\/?$/.test(github_url)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '‚ö†Ô∏è GitHub URL doesn\'t look right. Expected format: `https://github.com/owner/repo`'
              });
              return;
            }

            // Verify the GitHub repo is public
            const repoMatch = github_url.match(/github\.com\/([^/]+)\/([^/]+)/);
            if (repoMatch) {
              try {
                const { data: repoData } = await github.rest.repos.get({
                  owner: repoMatch[1],
                  repo: repoMatch[2].replace(/\/$/, ''),
                });
                if (repoData.private) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: '‚ö†Ô∏è This repository is private. Tiny Tool Town only lists public, open source tools. Please make the repo public and re-submit.'
                  });
                  return;
                }
              } catch (err) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: '‚ö†Ô∏è Could not access the GitHub repository. Please make sure the URL is correct and the repo is public.'
                });
                return;
              }
            }

            // Sanitize strings for YAML ‚Äî strip newlines and control chars
            const sanitize = (s) => s.replace(/[\r\n]+/g, ' ').replace(/[^\x20-\x7E\xA0-\uFFFF]/g, '').trim();
            const yamlStr = (s) => `"${sanitize(s).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;

            // Build tags array
            const tags = tagsRaw.split(',').map(t => sanitize(t)).filter(Boolean);

            // Generate slug from tool name (only alphanumeric + hyphens)
            const slug = sanitize(name).toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-|-$/g, '');

            if (!slug || slug.length < 2) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '‚ö†Ô∏è Tool name produced an invalid slug. Please use a name with at least 2 alphanumeric characters.'
              });
              return;
            }

            // Build frontmatter with proper YAML escaping
            const today = new Date().toISOString().split('T')[0];
            const lines = [
              '---',
              `name: ${yamlStr(name)}`,
              `tagline: ${yamlStr(tagline)}`,
              `author: ${yamlStr(author)}`,
              `author_github: "${sanitize(author_github).replace(/[^a-zA-Z0-9_-]/g, '')}"`,
              `github_url: "${sanitize(github_url)}"`,
            ];
            if (website_url && website_url !== '_No response_') {
              lines.push(`website_url: "${sanitize(website_url)}"`);
            }
            lines.push(`tags: [${tags.map(t => `"${t.replace(/"/g, '')}"`).join(', ')}]`);
            if (language && language !== '_No response_') {
              lines.push(`language: "${sanitize(language).replace(/"/g, '')}"`);
            }
            if (license && license !== '_No response_') {
              lines.push(`license: "${sanitize(license).replace(/"/g, '')}"`);
            }
            lines.push(`date_added: "${today}"`);
            lines.push('featured: false');
            lines.push('---');
            lines.push('');
            lines.push(description);

            const content = lines.join('\n');
            const filePath = `src/content/tools/${slug}.md`;

            // Check if file already exists
            const fs = require('fs');
            if (fs.existsSync(filePath)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ö†Ô∏è A tool with slug \`${slug}\` already exists. Please rename and re-submit.`
              });
              return;
            }

            // Write the file
            fs.writeFileSync(filePath, content);

            // Git commit and push using array args to avoid shell injection
            const { execFileSync } = require('child_process');
            execFileSync('git', ['config', 'user.name', 'Tiny Tool Town Bot']);
            execFileSync('git', ['config', 'user.email', 'bot@tinytooltown.com']);
            execFileSync('git', ['add', filePath]);
            execFileSync('git', ['commit', '-m', `üè† Add ${sanitize(name)} (from issue #${issue.number})`]);
            execFileSync('git', ['push']);

            // Close the issue with a comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `üèòÔ∏è **Welcome to Tiny Tool Town!**\n\n**${sanitize(name)}** has been added and will be live on [tinytooltown.com](https://www.tinytooltown.com/tools/${slug}/) once the site rebuilds (about 1 minute).\n\nThanks for sharing your tool! ‚ú®`
            });

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed'
            });

            console.log(`‚úÖ Added ${sanitize(name)} as ${filePath}`);

name: Refresh Thumbnails

on:
  schedule:
    - cron: '0 4 * * 0'  # Sunday 4am UTC
  workflow_dispatch:

concurrency:
  group: refresh-thumbnails
  cancel-in-progress: false

permissions:
  contents: write
  issues: read
  actions: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Refresh all tool thumbnails
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const TOOLS_DIR = 'src/content/tools';
            const THUMBS_DIR = 'public/thumbnails';
            const MIN_IMAGE_SIZE = 10 * 1024;
            const FETCH_TIMEOUT = 15000;

            // Fetch with timeout helper
            async function fetchWithTimeout(url, opts = {}) {
              return await fetch(url, opts);
            }

            const badgeHosts= ['img.shields.io', 'badge.fury.io', 'badgen.net', 'badges.', 'coveralls.io', 'codecov.io', 'travis-ci.', 'ci.appveyor.com', 'github.com/workflows'];
            const isBadge = (u) => badgeHosts.some(h => u.includes(h)) || u.includes('/badge');
            const safeExt = (urlStr) => {
              const allowed = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg'];
              try {
                const ext = path.extname(new URL(urlStr).pathname).split('?')[0].toLowerCase();
                return allowed.includes(ext) ? ext : '.png';
              } catch { return '.png'; }
            };

            if (!fs.existsSync(THUMBS_DIR)) fs.mkdirSync(THUMBS_DIR, { recursive: true });

            // Fetch all closed issues (approved tools)
            const allIssues = [];
            for (let page = 1; page <= 10; page++) {
              const { data } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                per_page: 100,
                page,
              });
              if (data.length === 0) break;
              allIssues.push(...data);
            }

            // Build map of tool name -> issue number (for comment image lookup)
            const issueMap = new Map();
            for (const issue of allIssues) {
              const body = issue.body || '';
              const nameMatch = body.match(/### Tool Name\s*\n\s*([\s\S]*?)(?=\n###|\n\n###|$)/);
              if (nameMatch) {
                const toolName = nameMatch[1].trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
                issueMap.set(toolName, issue.number);
              }
            }

            const files = fs.readdirSync(TOOLS_DIR).filter(f => f.endsWith('.md'));
            let updated = 0;
            let fetchErrors = 0;

            for (const file of files) {
              const slug = file.replace(/\.md$/, '');
              const content = fs.readFileSync(path.join(TOOLS_DIR, file), 'utf-8');

              // Parse github_url from frontmatter
              const urlMatch = content.match(/github_url:\s*"?([^"\n]+)"?/);
              if (!urlMatch) continue;
              const githubUrl = urlMatch[1].trim();

              const repoMatch = githubUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
              if (!repoMatch) continue;
              const [, repoOwner, repoName] = repoMatch;

              console.log(`\nüîç ${slug}:`);

              let bestImageUrl = null;
              let imageSource = '';
              let readmeBuffer = null;

              // 1. Check issue comments for uploaded images
              const issueNum = issueMap.get(slug);
              if (issueNum) {
                try {
                  const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNum,
                  });
                  // Check comments in reverse (newest first)
                  for (const comment of [...comments].reverse()) {
                    const commentBody = comment.body || '';
                    // Skip bot comments
                    if (comment.user?.login === 'github-actions[bot]') continue;
                    const imgMatch = commentBody.match(/!\[[^\]]*\]\((https?:\/\/[^)]+)\)/);
                    if (imgMatch) {
                      bestImageUrl = imgMatch[1];
                      imageSource = 'issue comment';
                      console.log(`  üì∏ Found image in issue #${issueNum} comment`);
                      break;
                    }
                  }
                } catch (e) {
                  console.log(`  ‚ö†Ô∏è Could not fetch comments for issue #${issueNum}`);
                }
              }

              // 2. Check README for images (if no comment image)
              if (!bestImageUrl) {
                for (const branch of ['main', 'master']) {
                  try {
                    const readmeRes = await fetchWithTimeout(`https://raw.githubusercontent.com/${repoOwner}/${repoName}/${branch}/README.md`);
                    if (!readmeRes.ok) continue;
                    const readme = await readmeRes.text();

                    const mdImgs = [...readme.matchAll(/!\[[^\]]*\]\(([^)]+)\)/g)].map(m => m[1]).filter(u => !isBadge(u));
                    const htmlImgs = [...readme.matchAll(/<img[^>]+src=["']([^"']+)["']/gi)].map(m => m[1]).filter(u => !isBadge(u));
                    const allImages = [...mdImgs, ...htmlImgs].slice(0, 5);

                    if (allImages.length === 0) continue;

                    // Download candidates and pick biggest
                    let biggest = null;
                    for (const imgPath of allImages) {
                      try {
                        let imgUrl = imgPath;
                        if (!imgPath.startsWith('http')) {
                          imgUrl = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/${branch}/${imgPath.replace(/^\.\//, '')}`;
                        }
                        const imgRes = await fetchWithTimeout(imgUrl);
                        if (!imgRes.ok) continue;
                        const buf = Buffer.from(await imgRes.arrayBuffer());
                        if (buf.length >= MIN_IMAGE_SIZE && (!biggest || buf.length > biggest.size)) {
                          biggest = { url: imgUrl, size: buf.length, buffer: buf };
                        }
                      } catch (e) { fetchErrors++; }
                    }

                    if (biggest) {
                      bestImageUrl = biggest.url;
                      imageSource = 'README';
                      console.log(`  üì∏ Found image in README (${(biggest.size / 1024).toFixed(1)} KB)`);
                      // Store buffer for direct write
                      biggest._stored = true;
                      readmeBuffer = biggest.buffer;
                    }
                    break;
                  } catch (e) { fetchErrors++; }
                }
              }

              if (!bestImageUrl) {
                console.log(`  ‚è≠Ô∏è No image found`);
                continue;
              }

              // Download the image (if not already buffered from README)
              const ext = safeExt(bestImageUrl);
              const thumbFile = `${slug}${ext}`;
              const thumbDest = path.join(THUMBS_DIR, thumbFile);
              const thumbPath = `/thumbnails/${thumbFile}`;

              try {
                let buf;
                if (typeof readmeBuffer !== 'undefined' && readmeBuffer && imageSource === 'README') {
                  buf = readmeBuffer;
                  readmeBuffer = null;
                } else {
                  const imgRes = await fetchWithTimeout(bestImageUrl);
                  if (!imgRes.ok) { console.log(`  ‚ùå Download failed: ${imgRes.status}`); continue; }
                  buf = Buffer.from(await imgRes.arrayBuffer());
                }

                if (buf.length < MIN_IMAGE_SIZE) {
                  console.log(`  ‚è≠Ô∏è Image too small (${(buf.length / 1024).toFixed(1)} KB)`);
                  continue;
                }

                // Check if image actually changed
                const existingThumb = fs.existsSync(thumbDest) ? fs.readFileSync(thumbDest) : null;
                if (existingThumb && Buffer.compare(buf, existingThumb) === 0) {
                  console.log(`  ‚úÖ Thumbnail unchanged`);
                  continue;
                }

                // Write new thumbnail
                fs.writeFileSync(thumbDest, buf);
                console.log(`  üíæ Saved ${thumbFile} (${(buf.length / 1024).toFixed(1)} KB) from ${imageSource}`);

                // Update frontmatter if thumbnail field missing or different
                if (!content.includes(`thumbnail: "${thumbPath}"`)) {
                  let updatedContent;
                  if (content.includes('thumbnail:')) {
                    updatedContent = content.replace(/thumbnail:.*/, `thumbnail: "${thumbPath}"`);
                  } else {
                    updatedContent = content.replace(/(github_url:.*\n)/, `$1thumbnail: "${thumbPath}"\n`);
                  }
                  fs.writeFileSync(path.join(TOOLS_DIR, file), updatedContent);
                  console.log(`  üìù Updated frontmatter`);
                }

                updated++;
              } catch (e) {
                console.log(`  ‚ùå Error: ${e.message}`);
              }
            }

            console.log(`\n‚úÖ Done! Updated ${updated} thumbnails.`);
            if (fetchErrors > 0) {
              console.log(`‚ö†Ô∏è ${fetchErrors} fetch errors occurred during processing.`);
            }
            if (updated === 0 && fetchErrors > files.length) {
              core.setFailed(`All thumbnail fetches failed (${fetchErrors} errors). Check runner environment.`);
            }

      - name: Commit and push changes
        run: |
          git config user.name "Tiny Tool Town Bot"
          git config user.email "bot@tinytooltown.com"
          git add -A
          if git diff --cached --quiet; then
            echo "No thumbnail changes detected"
          else
            CHANGED=$(git diff --cached --name-only | wc -l)
            git commit -m "üñºÔ∏è Refresh thumbnails ($CHANGED files updated)"
            git push
          fi

      - name: Trigger site rebuild
        run: |
          curl -s -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/deploy.yml/dispatches \
            -d '{"ref":"main"}'
